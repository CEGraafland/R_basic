#
# # permutate distance vector to find belong distance vector for igraph object
# newdistances <- distances[indsame]
# newdistances <- numeric(nrow(as_edgelist(igraph)))
# for (i in 1:nrow(as_edgelist(igraph))){
#   ind <- indsame[i]
#   as_edgelist(igraph)[ind,]
#   newdistances[ind] <- distances[i]
# }
# newdistances
E(igraph)$distances <- distances
# if(!dir){as.undirected(igraph)}
return(igraph)
}
igraph.distances.2(igraph,TimeCoordsAnom_from_Grid_rms(TP_interim_5d_bil))
warnings()
testa <- igraph.distances.2(igraph,TimeCoordsAnom_from_Grid_rms(TP_interim_5d_bil))
# newdistances <- numeric(nrow(as_edgelist(igraph)))
# for (i in 1:nrow(as_edgelist(igraph))){
#   ind <- indsame[i]
#   as_edgelist(igraph)[ind,]
#   newdistances[ind] <- distances[i]
# }
# newdistances
E(igraph)$distances <- newdistances
# newdistances <- numeric(nrow(as_edgelist(igraph)))
# for (i in 1:nrow(as_edgelist(igraph))){
#   ind <- indsame[i]
#   as_edgelist(igraph)[ind,]
#   newdistances[ind] <- distances[i]
# }
# newdistances
E(igraph)$distances <- distances
all.equal(igraph,testa)
igraph
all.equal(E(igraph)$distances, E(testa)$distances)
E(igraph$distances)[288]
E(igraph)$distances[288]
E(testa)$distances[288]
which(is.NA(E(igraph)$distances))
which(is.na(E(igraph)$distances))
which(E(testa)$distances))
whichis.na(E(testa)$distances))
which(is.na(E(testa)$distances))
nai <- which(is.na(E(igraph)$distances))
naa <- which(is.na(E(testa)$distances))
all.equal(nai,naa)
which(nai =!naa)
which(nai !=naa)
igraph <- graph_from_Grid(grid = gridused, method = "pearson", tau = 0.35)
igraph <- graph_from_Grid(grid = gridused, method = "pearson", th = 0.35)
data.igraph <- TimeCoordsAnom_from_Grid_rms(TP_interim_5d_bil,rms = TRUE)
# perm <- permutations[[1]]
require(data.table)
nodenames <- V(igraph)$name
# Check if class is igraph or bn, add characteristics for plotting purpose
if (is.null(V(igraph)$name)) {
names <- c()
names
for(i in 1:length(V(igraph))) names <- append(names,paste0("V",i))
V(igraph)$name <- names
nodenames <- V(igraph)$name
# as.directed(igraph, mode = "arbitrary")
}
nodenames
# Make edgelist in igraph class by edgeindices adjacancy matrix
# for selecting edgeindices when applying Haversine
adjmat <- as.matrix(as_adjacency_matrix(igraph))
igraph <- graph_from_Grid(grid = gridused, method = "pearson", th = 0.35)$igraph
data.igraph <- TimeCoordsAnom_from_Grid_rms(TP_interim_5d_bil,rms = TRUE)
# perm <- permutations[[1]]
require(data.table)
nodenames <- V(igraph)$name
# Check if class is igraph or bn, add characteristics for plotting purpose
if (is.null(V(igraph)$name)) {
names <- c()
names
for(i in 1:length(V(igraph))) names <- append(names,paste0("V",i))
V(igraph)$name <- names
nodenames <- V(igraph)$name
# as.directed(igraph, mode = "arbitrary")
}
nodenames
# Make edgelist in igraph class by edgeindices adjacancy matrix
# for selecting edgeindices when applying Haversine
adjmat <- as.matrix(as_adjacency_matrix(igraph))
adjmattri <- adjmat
gfG <- graph_from_Grid(grid = gridused, method = "pearson", th = 0.35)
igraph <- gfG$graph
data.igraph <- TimeCoordsAnom_from_Grid_rms(TP_interim_5d_bil,rms = TRUE)
# perm <- permutations[[1]]
require(data.table)
nodenames <- V(igraph)$name
# Check if class is igraph or bn, add characteristics for plotting purpose
if (is.null(V(igraph)$name)) {
names <- c()
names
for(i in 1:length(V(igraph))) names <- append(names,paste0("V",i))
V(igraph)$name <- names
nodenames <- V(igraph)$name
# as.directed(igraph, mode = "arbitrary")
}
nodenames
# Make edgelist in igraph class by edgeindices adjacancy matrix
# for selecting edgeindices when applying Haversine
adjmat <- as.matrix(as_adjacency_matrix(igraph))
adjmattri <- adjmat
# if(!dir){adjmattri[upper.tri(adjmattri)] <- 0}
edgeindices <- which(adjmattri == 1, arr.ind = TRUE)
edgeindices
as_edgelist(igraph)
fromV <- nodenames[edgeindices[,2]]
toV <- nodenames[edgeindices[,1]]
fromtoV <- cbind(fromV,toV)
# Make coordinates for every variable
longitude <- attributes(data.igraph)$VertexCoords$x
lattitude <- attributes(data.igraph)$VertexCoords$y
if (!is.null(perm)){
longitude <- longitude[perm]
lattitude <- lattitude[perm]
}
# estimate distance of all edges in igraph-edgelist.
distances <- c()
ndistdists <- 36*2592
for (i in 1:ndistdists){
x1Lat <- lattitude[edgeindices[i,1]]
x1Lon <- longitude[edgeindices[i,1]]
x2Lat <- lattitude[edgeindices[i,2]]
x2Lon <- longitude[edgeindices[i,2]]
disti <- haversine(x2Lat,x2Lon,x1Lat,x1Lon)
distances[i] <- disti
}
igraph.distances(igraph,igraph.data)
igraph.distances(igraph,data.igraph)
f1 <- igraph.distances(igraph,data.igraph)
f2 <- igraph.distances.2(igraph,data.igraph)
all.equal(f1,f2)
gfG <- graph_from_Grid(grid = gridused, method = "pearson", th = 0.35)
igraph <- gfG$graph
# criterion <- NULL
# k <- NULL
# data.dag <- TimeCoordsAnom_from_Grid(tas_ncep_10d)
# perm <- permutations[[1]]
require(data.table)
nodenames <- V(igraph)$name
# Check if class is igraph or bn, add characteristics for plotting purpose
if (is.null(V(igraph)$name)) {
names <- c()
names
for(i in 1:length(V(igraph))) names <- append(names,paste0("V",i))
V(igraph)$name <- names
nodenames <- V(igraph)$name
# as.directed(igraph, mode = "arbitrary")
}
# Make edgelist in igraph class by edgeindices adjacancy matrix
# for selecting edgeindices when applying Haversine
adjmat <- as.matrix(as_adjacency_matrix(igraph))
adjmattri <- adjmat
# if(!dir){adjmattri[upper.tri(adjmattri)] <- 0}
edgeindices <- which(adjmattri == 1, arr.ind = TRUE)
edgeindices
fromV <- nodenames[edgeindices[,2]]
toV <- nodenames[edgeindices[,1]]
fromtoV <- cbind(fromV,toV)
# Make coordinates for every variable
longitude <- attributes(data.igraph)$VertexCoords$x
lattitude <- attributes(data.igraph)$VertexCoords$y
if (!is.null(perm)){
longitude <- longitude[perm]
lattitude <- lattitude[perm]
}
# estimate distance of all edges in igraph-edgelist.
distances <- c()
for (i in 1:nrow(edgeindices)){
x1Lat <- lattitude[edgeindices[i,1]]
x1Lon <- longitude[edgeindices[i,1]]
x2Lat <- lattitude[edgeindices[i,2]]
x2Lon <- longitude[edgeindices[i,2]]
disti <- haversine(x1Lat,x1Lon,x2Lat,x2Lon)
distances[i] <- disti}
# newdistances <- numeric(nrow(as_edgelist(igraph)))
# for (i in 1:nrow(as_edgelist(igraph))){
#   ind <- indsame[i]
#   as_edgelist(igraph)[ind,]
#   newdistances[ind] <- distances[i]
# }
# newdistances
E(igraph)$distances <- distances
E(igraph)$distances
distances
E(igraph)$distances
distances
attributes(data.igraph)$VertexCoords$x
edgeindices
edgeindices[,2]
as_edgelist(igraph)
E(igraph)[3]
as_edgelist(igraph)[3]
as_edgelist(igraph)[3,]
as_ids(V(igraph))
as_ids(E(igraph))
as_ids(edgeindices[,2])
g <- make_ring(10)
as_ids(V(g))
as_ids(E(g))
adjmattri
edgeindices
as_edgelist(igraph)
edgeindices[,2]
longitude
edgeindices[,2]
edgeindices
adjmattri <- adjmat
adjmattri[upper.tri(adjmattri)] <- 0
edgeindices <- which(adjmattri == 1, arr.ind = TRUE)
edgeindices
edgeindices[,2]
edgeindices
as_edgelist(igraph)
edgeindices
gfG <- graph_from_Grid(grid = gridused, method = "pearson", th = 0.35)
igraph <- gfG$graph
nodenames <- V(igraph)$name
# Check if class is igraph or bn, add characteristics for plotting purpose
if (is.null(V(igraph)$name)) {
names <- c()
names
for(i in 1:length(V(igraph))) names <- append(names,paste0("V",i))
V(igraph)$name <- names
nodenames <- V(igraph)$name
# as.directed(igraph, mode = "arbitrary")
}
# Make edgelist in igraph class by edgeindices adjacancy matrix
# for selecting edgeindices when applying Haversine
adjmat <- as.matrix(as_adjacency_matrix(igraph))
adjmattri <- adjmat
adjmattri[upper.tri(adjmattri)] <- 0
edgeindices <- which(adjmattri == 1, arr.ind = TRUE)
fromV <- nodenames[edgeindices[,2]]
toV <- nodenames[edgeindices[,1]]
fromtoV <- cbind(fromV,toV)
# Make coordinates for every variable
longitude <- attributes(data.igraph)$VertexCoords$x
lattitude <- attributes(data.igraph)$VertexCoords$y
if (!is.null(perm)){
longitude <- longitude[perm]
lattitude <- lattitude[perm]
}
# estimate distance of all edges in igraph-edgelist.
distances <- c()
for (i in 1:nrow(edgeindices)){
x1Lat <- lattitude[edgeindices[i,2]]
x1Lon <- longitude[edgeindices[i,2]]
x2Lat <- lattitude[edgeindices[i,1]]
x2Lon <- longitude[edgeindices[i,1]]
disti <- haversine(x1Lat,x1Lon,x2Lat,x2Lon)
distances[i] <- disti}
# newdistances <- numeric(nrow(as_edgelist(igraph)))
# for (i in 1:nrow(as_edgelist(igraph))){
#   ind <- indsame[i]
#   as_edgelist(igraph)[ind,]
#   newdistances[ind] <- distances[i]
# }
# newdistances
E(igraph)$distances <- distances
igraph.distances.2 <- function(igraph, data.igraph, k = NULL, criterion = NULL, perm = NULL){
#gfG <- graph_from_Grid(grid = gridused, method = "pearson", th = 0.35)
#igraph <- gfG$graph
require(data.table)
nodenames <- V(igraph)$name
# Check if class is igraph or bn, add characteristics for plotting purpose
if (is.null(V(igraph)$name)) {
names <- c()
names
for(i in 1:length(V(igraph))) names <- append(names,paste0("V",i))
V(igraph)$name <- names
nodenames <- V(igraph)$name
# as.directed(igraph, mode = "arbitrary")
}
# dir <- is.directed(igraph)
# if(!dir){as.directed(igraph, mode = "arbitrary")}
# Make edgelist in igraph class by edgeindices adjacancy matrix
# for selecting edgeindices when applying Haversine
adjmat <- as.matrix(as_adjacency_matrix(igraph))
adjmattri <- adjmat
adjmattri[upper.tri(adjmattri)] <- 0
edgeindices <- which(adjmattri == 1, arr.ind = TRUE)
fromV <- nodenames[edgeindices[,2]]
toV <- nodenames[edgeindices[,1]]
fromtoV <- cbind(fromV,toV)
# Make coordinates for every variable
longitude <- attributes(data.igraph)$VertexCoords$x
lattitude <- attributes(data.igraph)$VertexCoords$y
if (!is.null(perm)){
longitude <- longitude[perm]
lattitude <- lattitude[perm]
}
# estimate distance of all edges in igraph-edgelist.
distances <- c()
for (i in 1:nrow(edgeindices)){
x1Lat <- lattitude[edgeindices[i,2]]
x1Lon <- longitude[edgeindices[i,2]]
x2Lat <- lattitude[edgeindices[i,1]]
x2Lon <- longitude[edgeindices[i,1]]
disti <- haversine(x1Lat,x1Lon,x2Lat,x2Lon)
distances[i] <- disti}
# # Make dataframe with departing variable, end variable and distance
# arcdistances <- cbind(unname(fromtoV), round(distances, digits = 3))
# nrow(arcdistances)
#
# # identify which indices in igraph edgelist correspond to indices in bn
# indsame <- c()
# nrow(as_edgelist(igraph))
# for (i in 1:nrow(as_edgelist(igraph))){
#   int <- intersect(which(arcdistances[,1] == as_edgelist(igraph)[i,1]),
#                    which(arcdistances[,2] == as_edgelist(igraph)[i,2]))
#   indsame[i] <- int
# }
#
# # permutate distance vector to find belong distance vector for igraph object
# newdistances <- distances[indsame]
# newdistances <- numeric(nrow(as_edgelist(igraph)))
# for (i in 1:nrow(as_edgelist(igraph))){
#   ind <- indsame[i]
#   as_edgelist(igraph)[ind,]
#   newdistances[ind] <- distances[i]
# }
# newdistances
E(igraph)$distances <- distances
# if(!dir){as.undirected(igraph)}
return(igraph)
}
f1 <- igraph.distances(igraph,data.igraph)
f2 <- igraph.distances.2(igraph,data.igraph)
all.equal(f1,f2)
igraph <- make_full_graph(2592,loops = FALSE, directed = FALSE)
data.igraph <- TimeCoordsAnom_from_Grid_rms(TP_interim_5d_bil,rms = TRUE)
f2 <- igraph.distances.2(igraph,data.igraph)
warnings()
gfG <- graph_from_Grid(grid = gridused, method = "pearson", th = 0.0)
igraph <- gfG$graph
data.igraph <- TimeCoordsAnom_from_Grid_rms(TP_interim_5d_bil,rms = TRUE)
f2 <- igraph.distances.2(igraph,data.igraph)
gfG <- graph_from_Grid(grid = gridused, method = "pearson", th = 0.01)
igraph <- gfG$graph
igraph <- make_full_graph(2592,loops = FALSE, directed = FALSE)
gfG <- graph_from_Grid(grid = gridused, method = "pearson", th = 0.01)
igraph <- gfG$graph
data.igraph <- TimeCoordsAnom_from_Grid_rms(TP_interim_5d_bil,rms = TRUE)
f2 <- igraph.distances.2(igraph,data.igraph)
#############################################################################
# For distance attribute;
# Create one time all distances (Full)
# Then check which edges are in full and assign edge attribute.
#############################################################################
rm(list = ls())
source("/oceano/gmeteo/WORK/lisette/Trabajo/R_practice/R/Functions/BasicNetworkFunctions.R")
source("/oceano/gmeteo/WORK/lisette/Trabajo/R_practice/R/Functions/CN_ConstructionandMeasuresFunctions.R")
source("/oceano/gmeteo/WORK/lisette/Trabajo/R_practice/R/Functions/propagationFunctions.R")
load("/oceano/gmeteo/WORK/lisette/Trabajo/R_practice/Data/interim/TP_interim_5d_bil.rda")
gridused <- TP_interim_5d_bil
tau <- c(0.53)
# tau <- seq(0.00,0.99,0.01)
gridGraphs_int_CN <- lapply(tau,graph_from_Grid, grid = gridused, method = "pearson")
# save(gridGraphs, file = "/Volumes/ubuntu/Trabajo/R_practice/Data/gridGraphs.rda")
graphs_int_CN <- lapply(gridGraphs_int_CN, function(x){x$graph})
nedges_int_CN <- lapply(graphs_int_CN , E)
nedges_int_CN <- sapply(nedges_int_CN, length)
names(graphs_int_CN) <- as.character(nedges_int_CN)
graphs_int_CNpearson_dist <- lapply(graphs_int_CN, igraph.distances.2, perm = NULL, data.dag = TimeCoordsAnom_from_Grid_rms(gridused, rms = TRUE))
graphs_int_CNpearson_dist <- lapply(graphs_int_CN, igraph.distances.2, perm = NULL, data.igraph= TimeCoordsAnom_from_Grid_rms(gridused, rms = TRUE))
graphs_int_CNpearson_dist$`12193`
save(graphs_int_CNpearson_dist, file = "/oceano/gmeteo/WORK/lisette/Trabajo/R_practice/Data/interim_struct_edgeattributes_TP/perm1/train1optgraph_int_TP_CNpearson_str_dist.rda")
####################################################################################
# Create graphs CN
###################################################################################
cortype <- "pearson"
tau <- seq(0.00,0.99,0.01)
pearsoncor <- cor(data_int_RMS, method = "pearson")
library(glasso)
library(igraph)
library(transformeR)
library(visualizeR)
library(bnlearn)
library(mvtnorm)
library(corpcor)
library(gridExtra)
library(condMVNorm)
library(RColorBrewer)
source("/oceano/gmeteo/WORK/lisette/Trabajo/R_practice/R/Functions/BasicNetworkFunctions.R")
source("/oceano/gmeteo/WORK/lisette/Trabajo/R_practice/R/Functions/CN_ConstructionandMeasuresFunctions.R")
source("/oceano/gmeteo/WORK/lisette/Trabajo/R_practice/R/Functions/propagationFunctions.R")
# load("/oceano/gmeteo/WORK/lisette/Trabajo/R_practice/Data/interim/tas_interim_10d.rda")
load("/oceano/gmeteo/WORK/lisette/Trabajo/R_practice/Data/interim/TP_interim_5d_bil.rda")
# f <- function(r,c,m){-m[r,c]/sqrt(m[r,r]*m[c,c])}
# Vecf <- Vectorize(f,vectorize.args = c('r','c'))
gridused <- TP_interim_5d_bil
#################################################################################
# Plain structure
#################################################################################
library(maps)
library(geosphere)
library(broom)
library(ggplot2)
####################################################################################
# Create graphs CN
###################################################################################
cortype <- "pearson"
tau <- seq(0.00,0.99,0.01)
pearsoncor <- cor(data_int_RMS, method = "pearson")
graphs_int_lluvia_CN <- lapply(X = tau, FUN = graph_from_cor,
grid = gridused, cormat = pearsoncor)
graphs_int_lluvia_CN <- lapply(X = tau, FUN = graph_from_cor,
grid = gridused, cormat = pearsoncor)
load("/oceano/gmeteo/WORK/lisette/Trabajo/R_practice/Data/interim_struct_edgeattributes_TP/perm1/train1optgraph_int_TP_CNpearson_str_dist.rda")
nedges_int_CN <- lapply(graphs_int_CNpearson_dist, E)
nedges_int_CN <- sapply(nedges_int_CN, length)
numbersCN <- c(53)
# cn:
whichsizesCN <- nedges_int_CN[numbersCN]
nedges_int_CN
numbersCN <- c(1)
# cn:
whichsizesCN <- nedges_int_CN[numbersCN]
cnlist <- graphs_int_CNpearson_dist[numbersCN]
graphObject <- TimeCoordsAnom_from_Grid_aslist(gridused)
graphObjects <- rep(list(graphObject),length(cnlist))
for (i in 1:length(graphObjects)){
graphObjects[[i]]$graph <- cnlist[[i]]
graphObjects[[i]]$adjacency <- as_adjacency_matrix(cnlist[[i]])
}
for (i in 1:length(cnlist)){
g <- cnlist[[i]]
ind <- which(E(g)$weights==0)
E(g)$weights[ind] <- 0.000000001
cnlist[[i]]<-g
}
weightscnlist <- lapply(cnlist, function(x)E(x)$weights)
closenesscn <- mapply(closeness, graph = cnlist, weights = weightscnlist, normalized = FALSE, SIMPLIFY = FALSE)
climclosenesscn <- lapply(closenesscn, quantity2clim, what = "closeness",ref.grid = gridused, backperm = backpermutations[[1]])
#########################################################################################
# topology evaluation
#########################################################################################
load(file = "/oceano/gmeteo/WORK/lisette/Trabajo/R_practice/Data/interim_struct_edgeattributes_TP/perm1/int_TP_perm1weights.rda")
##########################################################################################
# permutations25_5d
##########################################################################################
load("/oceano/gmeteo/WORK/lisette/Trabajo/R_practice/Data/interim_struct_TP/datapermutations25_5d.rda")
load("/oceano/gmeteo/WORK/lisette/Trabajo/R_practice/Data/interim_struct_TP/permutations25_5d.rda")
################################################
# Backpermutations BN
################################################
backpermutations25_5d <- list()
for (j in 1:length(datapermutations25_5d)){
indback <- c()
for (i in 1:ncol(datapermutations25_5d[[1]])){
intback <- which(colnames(datapermutations25_5d[[j]]) == colnames(datapermutations25_5d[[1]][i]))
indback[i] <- intback
}
backpermutations25_5d[[j]] <- indback
}
climclosenesscn <- lapply(closenesscn, quantity2clim, what = "closeness",ref.grid = gridused, backperm = backpermutations25_5d[[1]])
cb <- colorRampPalette(brewer.pal(9, "YlOrRd"))(80)
attr(climclosenesscn[[1]]$Data, "climatology:fun")
plotscn <- list()
meas <- climclosenesscn
for (i in 1:length(meas)){
plot <- spatialPlot(meas[[i]], main = list(paste0("CN:",whichsizesCN[[i]]), cex = 0.5),
backdrop.theme = "coastline",
region = TRUE, col.regions= cb,
# set.max = 20000,
colorkey = list(width = 0.6, lables = list(cex = 0.5)))
plotscn[[i]] <- plot
}
plotscn
do.call(grid.arrange, c(plotscn, nrow = 2, as.table = TRUE, top = paste0(attr(meas[[1]]$Data, "climatology:fun"))))
##############################################################################
# Unweighted betweenness
#####################################################################################
weights1cnlist <- lapply(cnlist, function(x)E(x)$weight)
betweennesscn <- mapply(betweenness,cnlist, weights = weights1cnlist, SIMPLIFY = FALSE) # HAS TO BE POSITIVE
logbetweennesscn <- lapply(betweennesscn, function(x)log(1+x))
movmed_betw_cn <- lapply(logbetweennesscn, movingmedias)
movmed_betw_cn_mean <- lapply(movmed_betw_cn, function(x) apply(x, MARGIN = 3, FUN = mean))
climbetwcn <- lapply(movmed_betw_cn_mean, quantity2clim, what = "betweenness",ref.grid = gridused)
plotscn <- list()
meas <- climbetwcn
for (i in 1:length(climbetwcn)){
plot <- spatialPlot(climbetwcn[[i]], main = list(paste0("CN:",whichsizesCN[[i]]), cex = 0.5),
backdrop.theme = "coastline",
lonCenter = 180,
col = "Reds",
at = seq(0,10,10/16),
colorkey = list(width = 0.6, lables = list(cex = 0.5))
)
plotscn[[i]] <- plot
}
do.call(grid.arrange, c(plotscn, nrow = 3, as.table = TRUE, top = paste0("Moving Medias CN: Log(1 + ",attr(meas[[1]]$Data, "climatology:fun"),")")))
data_int_RMS <- TimeCoordsAnom_from_Grid_rms(gridused, rms = TRUE)
pearsoncor <- cor(data_int_RMS, method = "pearson")
graphs_int_lluvia_CN <- lapply(X = tau, FUN = graph_from_cor,
grid = gridused, cormat = pearsoncor)
tau <- c(0.53,0.35)
# tau <- seq(0.00,0.99,0.01)
gridGraphs_int_CN <- lapply(tau,graph_from_Grid, grid = gridused, method = "pearson")
# save(gridGraphs, file = "/Volumes/ubuntu/Trabajo/R_practice/Data/gridGraphs.rda")
graphs_int_CN <- lapply(gridGraphs_int_CN, function(x){x$graph})
nedges_int_CN <- lapply(graphs_int_CN , E)
nedges_int_CN <- sapply(nedges_int_CN, length)
names(graphs_int_CN) <- as.character(nedges_int_CN)
graphs_int_CNpearson_dist <- lapply(graphs_int_CN, igraph.distances.2, perm = NULL, data.igraph= TimeCoordsAnom_from_Grid_rms(gridused, rms = TRUE))
save(graphs_int_CNpearson_dist, file = "/oceano/gmeteo/WORK/lisette/Trabajo/R_practice/Data/interim_struct_edgeattributes_TP/perm1/train1optgraph_int_TP_CNpearson_str_dist.rda")
